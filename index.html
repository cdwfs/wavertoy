<!doctype html>
<head>
	<title>Wavertoy</title>
	<style type="text/css" media="screen">
    #editor {
        margin: 0;
        position: relative !important;
		width: 90%;
		height: 300px;
    }
	</style>
</head>
<body>

	<!-- Editor -->
	<pre id="editor" style="font-size:18px">
// Generate samples based on the "time" parameter.
var sample = sin(6.2831 * 220.0 * time);
// Store final sample values in the "left" and "right" variables.
left = sample;
right = sample;</pre>

	<script src="lib/src-min-noconflict/ace.js" charset="utf-8"></script>
	<script>
	var editor = ace.edit("editor");
	editor.$blockScrolling = Infinity;
	editor.setTheme("ace/theme/xcode");
	editor.getSession().setMode("ace/mode/javascript");
    editor.commands.addCommand({
        name: "runSound",
        bindKey: {win: "Ctrl-Enter", mac: "Command-Enter"},
        exec: function(editor) {
			//console.log("running!");
			waver.start();
        }
    });
    editor.commands.addCommand({
        name: "stopSound",
        bindKey: {win: "Ctrl-Space", mac: "Command-Space"},
        exec: function(editor) {
			//console.log("stopping!");
			waver.stop();
        }
    });
	// add command to lazy-load keybinding_menu extension
    editor.commands.addCommand({
        name: "showKeyboardShortcuts",
        bindKey: {win: "Ctrl-Alt-h", mac: "Command-Alt-h"},
        exec: function(editor) {
			console.log("helping!");
            ace.config.loadModule("ace/ext/keybinding_menu", function(module) {
                module.init(editor);
                editor.showKeyboardShortcuts()
            })
        }
    });
	</script>
	
	<!-- Audio generator -->
	<script>
	var waver = function() {
		"use strict";
		var audioCtx = new AudioContext();
		var sampleBufferSize = 1024;
		var inputChannelCount = 0;
		var outputChannelCount = 2;
		var scriptNode = audioCtx.createScriptProcessor(sampleBufferSize,
			inputChannelCount, outputChannelCount);
		var samplesCopy = {
			left: new Float32Array(sampleBufferSize),
			right: new Float32Array(sampleBufferSize)
		};
		var elapsedTime = 0;
		var secondsPerSample = 1.0 / audioCtx.sampleRate;
		var peakAmplitude = 0.2;
		var isRunning = false;
		
		var sampleGen = function(time) { return [0,0] };
		var updateCode = function() {
			sampleGen = new Function('time',
				'"use strict";\n'
					//+ 'try {\n'
					+ 'var left = 0;\n'
					+ 'var right = 0;\n'
					+ 'var sin = function(x) { return Math.sin(x); };\n'
					+ 'var cos = function(x) { return Math.cos(x); };\n'
					+ 'var tan = function(x) { return Math.tan(x); };\n'
					+ 'var exp = function(x) { return Math.exp(x); };\n'
					+ 'var fract = function(x) { return x - Math.floor(x); };\n'
					+ editor.getValue()
					+ 'return [left,right];\n'
					//+ '} catch(e) { alert(e.message); }\n'
			);
		};
		scriptNode.onaudioprocess = function(audioProcessingEvent) {
			var outputBuffer = audioProcessingEvent.outputBuffer;
			var leftChan  = outputBuffer.getChannelData(0);
			var rightChan = outputBuffer.getChannelData(1);
			for (var iSamp=0; iSamp<this.bufferSize; iSamp += 1) {
				var samples = sampleGen(elapsedTime);
				samplesCopy.left[iSamp] = leftChan[iSamp] = samples[0] * peakAmplitude;
				samplesCopy.right[iSamp] = rightChan[iSamp] = samples[1] * peakAmplitude;
				elapsedTime += secondsPerSample;
			}
		};
		
		return {
			"start": function() {
				var oldFunc = sampleGen;
				try {
					updateCode();
				} catch(e) {
					alert(e.name + "\n" + e.message);
					sampleGen = oldFunc;
				}
				scriptNode.connect(audioCtx.destination); this.reset();
				isRunning = true;
			},
			"stop": function() { scriptNode.disconnect(); isRunning = false; },
			"reset": function() { elapsedTime = 0.0; },
			"isRunning": function() { return isRunning; },
			"getBufferSize": function() { return scriptNode.bufferSize; },
			"getSamples": function() { return samplesCopy; }
		};
	}();
	</script>
	<form name="soundCode"> 
		<input type="button" value="Run (ctrl-Enter)" onClick="waver.start();"/>
		<input type="button" value="Stop (ctrl-Space)" onClick="waver.stop();"/>
	</form>
	<H2>Example:</H2>
	<pre>
var p = 10*sin(time) * sin(6.2831 * 220.0 * time);
var sample = sin(6.2831 * 220.0 * time + p) * exp(-4.0*fract(4*time));

sample += sin(100 * time * exp(-10 * fract(2*time)));

left = sample;
right = sample;
	</pre>

	<H2>TODO:</H2>
	<UL>
		<LI>Documentation</LI>
		<LI>UI controls for:<UL>
			<LI>Gain</LI>
			<LI>Audio buffer size</LI>
		</UL></LI>
		<LI>Error reporting (syntax error, failure to set left/right, etc.)</LI>
	</UL>
		
	<!-- Waveform display -->
	<script src="lib/Detector.js"></script>
	<script src="lib/three.min.js"></script>
	<script>
	var waveDisplay = function() {
		"use strict";
		
		var scene, camera, renderer, waveLObj, waveRObj;
		function init() {
			if (!Detector.webgl) {
				Detector.addGetWebGLMessage();
			}
			
			scene = new THREE.Scene();
			
			camera = new THREE.OrthographicCamera(-1, 1, 1, -1, -1, 1);
			
			renderer = new THREE.WebGLRenderer();
			renderer.setClearColor(0x000000, 1.0);
			renderer.setSize(window.innerWidth*0.9, 300);

			var zeroLGeom = new THREE.Geometry();
			zeroLGeom.vertices.push( new THREE.Vector3(-1,  0.5, -0.5) );
			zeroLGeom.vertices.push( new THREE.Vector3( 1,  0.5, -0.5) );
			var zeroRGeom = new THREE.Geometry();
			zeroRGeom.vertices.push( new THREE.Vector3(-1, -0.5, -0.5) );
			zeroRGeom.vertices.push( new THREE.Vector3( 1, -0.5, -0.5) );
			var zeroMat = new THREE.LineBasicMaterial({color:0x4040C0});
			scene.add( new THREE.Line(zeroLGeom, zeroMat) );
			scene.add( new THREE.Line(zeroRGeom, zeroMat) );
			
			var waveMat = new THREE.LineBasicMaterial({color: 0xFFFFFF});
			var iVert;
			var waveLGeom = new THREE.Geometry();
			for(iVert=0; iVert<waver.getBufferSize(); iVert+=1) {
				var vertX = (iVert/waver.getBufferSize()) * 2.0 - 1.0;
				waveLGeom.vertices.push( new THREE.Vector3(vertX, 0, 0));
			}
			waveLObj = new THREE.Line(waveLGeom, waveMat);
			waveLObj.translateY(0.5);
			waveLObj.scale.y = 0.5;
			waveLObj.name = "waveL";
			scene.add(waveLObj);
			
			var waveRGeom = new THREE.Geometry();
			for(iVert=0; iVert<waver.getBufferSize(); iVert+=1) {
				var vertX = (iVert/waver.getBufferSize()) * 2.0 - 1.0;
				waveRGeom.vertices.push( new THREE.Vector3(vertX, 0, 0));
			}
			waveRObj = new THREE.Line(waveRGeom, waveMat);
			waveRObj.translateY(-0.5);
			waveRObj.scale.y = 0.5;
			waveRObj.name = "waveR";
			scene.add(waveRObj);
			
			document.body.insertBefore(renderer.domElement, document.body.firstChild);
			render();			
		}
		
		function render() {
			var iVert;
			var vertsL = waveLObj.geometry.vertices;
			var vertsR = waveRObj.geometry.vertices;
			if (waver.isRunning()) {
				var samples = waver.getSamples();
				for(iVert=0; iVert < vertsL.length; iVert += 1) {
					vertsL[iVert].y = samples.left[iVert];
					vertsR[iVert].y = samples.right[iVert];
				}
			} else {
				for(iVert=0; iVert < vertsL.length; iVert += 1) {
					vertsL[iVert].y *= 0.5;
					vertsR[iVert].y *= 0.5;
				}
			}
			waveLObj.geometry.verticesNeedUpdate = true;
			waveRObj.geometry.verticesNeedUpdate = true;
			
			renderer.render(scene, camera);
			requestAnimationFrame(render);
		}
		
		window.onload = init;		
	}();
	</script>
</body>
